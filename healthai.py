import pandas as pd
import numpy as np
import streamlit as st
from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import datetime
import json
import os
import hashlib
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Initialize FastAPI app
app = FastAPI(title="HealthAI API", description="Backend for HealthAI Intelligent Healthcare Assistant")

# Define data models
class Patient(BaseModel):
    id: str
    name: str
    age: int
    gender: str
    password: str
    medical_history: List[str] = []
    allergies: List[str] = []
    current_medications: List[str] = []

class Admin(BaseModel):
    username: str
    password: str

class Symptom(BaseModel):
    symptom_name: str
    severity: int = Field(..., ge=1, le=10)
    duration_days: int
    additional_notes: Optional[str] = None

class QueryRequest(BaseModel):
    patient_id: str
    symptoms: List[Symptom]
    previous_diagnoses: Optional[List[str]] = None
    additional_context: Optional[str] = None

class DiagnosisResponse(BaseModel):
    patient_id: str
    possible_diagnoses: List[Dict[str, Any]]
    recommendations: List[str]
    follow_up_required: bool
    urgent_care_recommended: bool
    ai_confidence_score: float
    timestamp: datetime.datetime

# Persistent storage functions
def save_patients_to_disk(patients):
    with open('patients_db.json', 'w') as f:
        json.dump(patients, f, default=str)

def load_patients_from_disk():
    if os.path.exists('patients_db.json'):
        with open('patients_db.json', 'r') as f:
            return json.load(f)
    return {}

def save_diagnoses_to_disk(diagnoses):
    with open('diagnoses_db.json', 'w') as f:
        json.dump(diagnoses, f, default=str)

def load_diagnoses_from_disk():
    if os.path.exists('diagnoses_db.json'):
        with open('diagnoses_db.json', 'r') as f:
            return json.load(f)
    return []

def save_admins_to_disk(admins):
    with open('admins_db.json', 'w') as f:
        json.dump(admins, f)

def load_admins_from_disk():
    if os.path.exists('admins_db.json'):
        with open('admins_db.json', 'r') as f:
            return json.load(f)
    default_admin = {
        "admin": {
            "username": "admin",
            "password": hashlib.sha256("admin123".encode()).hexdigest()
        }
    }
    save_admins_to_disk(default_admin)
    return default_admin

# Hash password function
def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest() if password else ""

# Load existing data or initialize empty containers
patients_db = load_patients_from_disk()
diagnoses_db = load_diagnoses_from_disk()
admins_db = load_admins_from_disk()

# Sample medical knowledge base
medical_conditions = {
    "common_cold": {
        "symptoms": ["runny nose", "sore throat", "cough", "sneezing", "mild fever"],
        "severity": "low",
        "requires_followup": False,
        "treatment": ["rest", "fluids", "over-the-counter cold medications"],
    },
    "influenza": {
        "symptoms": ["high fever", "body aches", "fatigue", "cough", "sore throat"],
        "severity": "medium",
        "requires_followup": True,
        "treatment": ["rest", "fluids", "antiviral medications if caught early"],
    },
    "covid19": {
        "symptoms": ["fever", "cough", "shortness of breath", "fatigue", "loss of taste or smell"],
        "severity": "high",
        "requires_followup": True,
        "treatment": ["isolation", "rest", "fluids", "monitoring oxygen levels"],
    },
    "hypertension": {
        "symptoms": ["headache", "shortness of breath", "chest pain", "dizziness"],
        "severity": "medium",
        "requires_followup": True,
        "treatment": ["medication", "diet changes", "exercise", "regular monitoring"],
    },
    "diabetes": {
        "symptoms": ["frequent urination", "increased thirst", "unexplained weight loss", "fatigue"],
        "severity": "medium",
        "requires_followup": True,
        "treatment": ["medication", "diet management", "regular blood sugar monitoring", "exercise"],
    },
}

# Mock LLM implementation
class MockLLM:
    def __call__(self, prompt):
        return f"Response for: {prompt[:50]}... (This is a placeholder response. In a real system, this would be generated by a language model.)"

class ConversationBufferMemory:
    def __init__(self):
        self.buffer = []
        
    def add_message(self, message):
        self.buffer.append(message)
        
    def get_history(self):
        return self.buffer

class ConversationChain:
    def __init__(self, llm, memory):
        self.llm = llm
        self.memory = memory

    def __call__(self, prompt):
        self.memory.add_message({"role": "user", "content": prompt})
        response = self.llm(prompt)
        self.memory.add_message({"role": "assistant", "content": response})
        return response

# Initialize LLM components
llm = MockLLM()
memory = ConversationBufferMemory()
conversation = ConversationChain(llm=llm, memory=memory)

# AI diagnosis model
class DiagnosisModel:
    def __init__(self):
        self.model = RandomForestClassifier()
        self.trained = False

    def train(self, X, y):
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
        self.model.fit(X_train, y_train)
        self.trained = True
        preds = self.model.predict(X_test)
        return {
            "accuracy": accuracy_score(y_test, preds),
            "precision": precision_score(y_test, preds, average='weighted'),
            "recall": recall_score(y_test, preds, average='weighted'),
            "f1": f1_score(y_test, preds, average='weighted'),
        }

    def _rule_based_prediction(self, symptoms):
        matches = {}
        for condition, details in medical_conditions.items():
            score = 0
            for symptom in details["symptoms"]:
                if any(s in symptom or symptom in s for s in symptoms):
                    score += 1
            if score > 0:
                confidence = min(score / len(details["symptoms"]), 1.0)
                matches[condition] = confidence

        # Sort by confidence
        sorted_matches = sorted(matches.items(), key=lambda x: x[1], reverse=True)
        return sorted_matches

    def predict(self, symptoms_vector):
        if not self.trained:
            return self._rule_based_prediction(symptoms_vector)
        return self.model.predict_proba([symptoms_vector])[0]

# Initialize diagnosis model
diagnosis_model = DiagnosisModel()

# API endpoints
@app.post("/register_patient", response_model=Patient)
async def register_patient(patient: Patient):
    if patient.id in patients_db:
        raise HTTPException(status_code=400, detail="Patient ID already exists")

    patient_dict = patient.dict()
    patient_dict["password"] = hash_password(patient_dict["password"])
    patients_db[patient.id] = patient_dict
    save_patients_to_disk(patients_db)
    return patient

@app.post("/login_patient")
async def login_patient(patient_id: str, password: str):
    if patient_id not in patients_db:
        raise HTTPException(status_code=404, detail="Patient not found")

    hashed_password = hash_password(password)
    if patients_db[patient_id]["password"] != hashed_password:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    return {"status": "success", "message": "Login successful"}

@app.post("/register_admin")
async def register_admin(admin: Admin):
    if admin.username in admins_db:
        raise HTTPException(status_code=400, detail="Admin already exists")

    admin_dict = admin.dict()
    admin_dict["password"] = hash_password(admin_dict["password"])
    admins_db[admin.username] = admin_dict
    save_admins_to_disk(admins_db)
    return admin

@app.post("/login_admin")
async def login_admin(username: str, password: str):
    if username not in admins_db:
        raise HTTPException(status_code=404, detail="Admin not found")

    hashed_password = hash_password(password)
    if admins_db[username]["password"] != hashed_password:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    return {"status": "success", "message": "Admin login successful"}

@app.get("/patient/{patient_id}")
async def get_patient(patient_id: str):
    if patient_id not in patients_db:
        raise HTTPException(status_code=404, detail="Patient not found")
    return patients_db[patient_id]

@app.post("/diagnose", response_model=DiagnosisResponse)
async def diagnose(request: QueryRequest):
    if request.patient_id not in patients_db:
        raise HTTPException(status_code=404, detail="Patient not found")

    # Extract symptoms list
    symptoms_list = [s.symptom_name.lower() for s in request.symptoms]
    symptom_severity = sum([s.severity for s in request.symptoms]) / len(request.symptoms)

    # Get predictions from model
    predictions = diagnosis_model._rule_based_prediction(symptoms_list)

    # Determine if urgent care is recommended
    urgent_care = symptom_severity > 7 or any(p[0] == "covid19" and p[1] > 0.6 for p in predictions)

    # Format possible diagnoses
    possible_diagnoses = []
    for condition, confidence in predictions[:3]:  # Top 3 predictions
        possible_diagnoses.append({
            "condition": condition,
            "confidence": confidence,
            "details": medical_conditions[condition],
            "recommended_actions": medical_conditions[condition]["treatment"],
        })

    # Generate recommendations
    recommendations = []
    for diag in possible_diagnoses:
        recommendations.extend(diag["recommended_actions"])
    recommendations.append("Stay hydrated")
    recommendations.append("Get adequate rest")

    # Determine follow-up based on severity
    follow_up_required = symptom_severity > 5 or any(d["details"]["requires_followup"] for d in possible_diagnoses)

    # Create response
    response = DiagnosisResponse(
        patient_id=request.patient_id,
        possible_diagnoses=possible_diagnoses,
        recommendations=list(set(recommendations)),  # Remove duplicates
        follow_up_required=follow_up_required,
        urgent_care_recommended=urgent_care,
        ai_confidence_score=possible_diagnoses[0]["confidence"] if possible_diagnoses else 0.0,
        timestamp=datetime.datetime.now(),
    )

    # Store diagnosis in database
    diagnosis_dict = response.dict()
    diagnoses_db.append(diagnosis_dict)
    save_diagnoses_to_disk(diagnoses_db)

    return response

@app.post("/ask_health_question")
async def ask_health_question(question: str = Query(..., min_length=5), patient_id: Optional[str] = None):
    patient_context = ""
    if patient_id and patient_id in patients_db:
        patient = patients_db[patient_id]
        patient_context = f"Patient context: {patient['age']} year old {patient['gender']} with history of {', '.join(patient['medical_history'])}"

    prompt = f"""
    You are HealthAI, an intelligent healthcare assistant. Please provide accurate, helpful medical information.
    Remember that you should not replace professional medical advice.

    {patient_context}

    Question: {question}
    """

    response = conversation(prompt)

    return {
        "question": question,
        "answer": response,
        "disclaimer": "This information is not a substitute for professional medical advice. Always consult with a qualified healthcare provider.",
    }

@app.get("/patient_history/{patient_id}")
async def get_patient_history(patient_id: str):
    if patient_id not in patients_db:
        raise HTTPException(status_code=404, detail="Patient not found")

    patient_diagnoses = [d for d in diagnoses_db if d["patient_id"] == patient_id]

    return {
        "patient_id": patient_id,
        "diagnosis_count": len(patient_diagnoses),
        "diagnoses": patient_diagnoses,
    }

# Streamlit Web Interface
def create_streamlit_app():
    st.set_page_config(page_title="HealthAI", page_icon="🏥", layout="wide")

    # Initialize session state
    if 'patients_db' not in st.session_state:
        st.session_state.patients_db = load_patients_from_disk()
    if 'diagnoses_db' not in st.session_state:
        st.session_state.diagnoses_db = load_diagnoses_from_disk()
    if 'admins_db' not in st.session_state:
        st.session_state.admins_db = load_admins_from_disk()
    if 'logged_in' not in st.session_state:
        st.session_state.logged_in = False
    if 'user_type' not in st.session_state:
        st.session_state.user_type = None
    if 'user_id' not in st.session_state:
        st.session_state.user_id = None
    if 'current_symptoms' not in st.session_state:
        st.session_state.current_symptoms = []
    if 'show_registration_form' not in st.session_state:
        st.session_state.show_registration_form = False

    # Display appropriate page based on login status
    if not st.session_state.logged_in:
        display_home_page()
    else:
        if st.session_state.user_type == "admin":
            display_admin_dashboard()
        elif st.session_state.user_type == "patient":
            display_patient_dashboard()

def display_patient_registration_form():
    st.header("Patient Registration")
    with st.form("patient_registration_form"):
        new_patient_id = st.text_input("Patient ID")
        name = st.text_input("Full Name")
        age = st.number_input("Age", min_value=0, max_value=120)
        gender = st.selectbox("Gender", ["Male", "Female", "Other"])
        password = st.text_input("Password", type="password")
        medical_history = st.text_area("Medical History (separate items with commas)")
        allergies = st.text_area("Allergies (separate items with commas)")
        current_medications = st.text_area("Current Medications (separate items with commas)")

        submit_button = st.form_submit_button("Register")

        if submit_button:
            if not new_patient_id or not name or not password:
                st.error("Patient ID, Name, and Password are required fields.")
            elif new_patient_id in st.session_state.patients_db:
                st.error("Patient ID already exists. Choose a different ID.")
            else:
                new_patient = Patient(
                    id=new_patient_id,
                    name=name,
                    age=age,
                    gender=gender,
                    password=hash_password(password),
                    medical_history=[item.strip() for item in medical_history.split(",") if item.strip()],
                    allergies=[item.strip() for item in allergies.split(",") if item.strip()],
                    current_medications=[item.strip() for item in current_medications.split(",") if item.strip()],
                )
                st.session_state.patients_db[new_patient_id] = new_patient.dict()
                save_patients_to_disk(st.session_state.patients_db)
                st.success(f"Patient {name} registered successfully with ID: {new_patient_id}")
                st.session_state.show_registration_form = False  # Hide form after successful registration
                st.rerun()

def display_home_page():
    st.title("🏥 HealthAI - Intelligent Healthcare Assistant")
    st.subheader("Welcome to your personal healthcare companion")

    # Login tabs
    tab1, tab2, tab3 = st.tabs(["Home", "Patient Login", "Admin Login"])

    with tab1:
        st.image("https://via.placeholder.com/800x400?text=HealthAI+Intelligent+Healthcare", use_column_width=True)
        st.markdown("""
        ### Your Intelligent Healthcare Assistant

        HealthAI provides personalized healthcare support with advanced diagnostic capabilities:

        - **Symptom Analysis**: Get potential diagnoses based on your symptoms
        - **Health Recommendations**: Personalized health advice
        - **Medical History**: Keep track of your health records
        - **Health Q&A**: Ask health-related questions and get reliable answers

        Register or login to get started!
        """)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("Patient Login", use_container_width=True):
                st.session_state.show_registration_form = False
                st.rerun()
        with col2:
            if st.button("Patient Registration", use_container_width=True):
                st.session_state.show_registration_form = True
                st.rerun()
        if st.session_state.show_registration_form:
            display_patient_registration_form()

    with tab2:
        st.header("Patient Login")
        patient_id = st.text_input("Patient ID", key="patient_login_id")
        password = st.text_input("Password", type="password", key="patient_login_password")

        if st.button("Login", key="patient_login_button"):
            if patient_id in st.session_state.patients_db:
                stored_password = st.session_state.patients_db[patient_id]["password"]
                hashed_password = hash_password(password)
                if stored_password == hashed_password:
                    st.success("Login successful!")
                    st.session_state.logged_in = True
                    st.session_state.user_type = "patient"
                    st.session_state.user_id = patient_id
                    st.rerun()
                else:
                    st.error("Incorrect patient credentials")
            else:
                st.error("Patient not found")

    with tab3:
        st.header("Admin Login")
        username = st.text_input("Username", key="admin_login_username")
        password = st.text_input("Password", type="password", key="admin_login_password")

        if st.button("Login", key="admin_login_button"):
            if username in st.session_state.admins_db:
                stored_password = st.session_state.admins_db[username]["password"]
                hashed_password = hash_password(password)
                if stored_password == hashed_password:
                    st.success("Login successful!")
                    st.session_state.logged_in = True
                    st.session_state.user_type = "admin"
                    st.session_state.user_id = username
                    st.rerun()
                else:
                    st.error("Incorrect admin credentials")
            else:
                st.error("Admin not found")

def display_patient_dashboard():
    st.title("Patient Dashboard")
    patient_id = st.session_state.user_id
    patient = st.session_state.patients_db[patient_id]
    
    st.write(f"Welcome back, {patient['name']}!")
    
    tabs = st.tabs(["Health Profile", "Symptom Checker", "Health History", "Ask Health Question"])
    
    with tabs[0]:
        st.subheader("Your Health Profile")
        col1, col2 = st.columns(2)
        with col1:
            st.write(f"**Name:** {patient['name']}")
            st.write(f"**Age:** {patient['age']}")
            st.write(f"**Gender:** {patient['gender']}")
        with col2:
            st.write("**Medical History:**")
            for item in patient['medical_history']:
                st.write(f"- {item}")
        
        st.write("**Allergies:**")
        for allergy in patient['allergies']:
            st.write(f"- {allergy}")
            
        st.write("**Current Medications:**")
        for med in patient['current_medications']:
            st.write(f"- {med}")
            
        if st.button("Edit Profile"):
            st.info("This feature is under development")
            
    with tabs[1]:
        st.subheader("Symptom Checker")
        st.write("Describe your symptoms for an AI-powered diagnosis")
        
        symptom_input = st.text_input("Enter symptom")
        symptom_severity = st.slider("Symptom Severity", 1, 10, 5)
        symptom_duration = st.number_input("Duration (days)", min_value=1, value=1)
        
        if st.button("Add Symptom"):
            if symptom_input:
                st.session_state.current_symptoms.append({
                    "symptom_name": symptom_input,
                    "severity": symptom_severity,
                    "duration_days": symptom_duration
                })
                st.success(f"Added symptom: {symptom_input}")
                st.rerun()
        
        st.write("Current Symptoms:")
        for i, symptom in enumerate(st.session_state.current_symptoms):
            st.write(f"{i+1}. {symptom['symptom_name']} (Severity: {symptom['severity']}, Duration: {symptom['duration_days']} days)")
        
        if st.session_state.current_symptoms and st.button("Get Diagnosis"):
            st.info("Processing diagnosis...")
            # This would normally call the API endpoint
            symptoms_list = [s["symptom_name"].lower() for s in st.session_state.current_symptoms]
            symptom_severity = sum([s["severity"] for s in st.session_state.current_symptoms]) / len(st.session_state.current_symptoms)
            
            # Get predictions directly
            predictions = diagnosis_model._rule_based_prediction(symptoms_list)
            
            st.subheader("Possible Conditions:")
            for condition, confidence in predictions[:3]:
                st.write(f"**{condition.title()}** (Confidence: {confidence:.2f})")
                st.write(f"Common symptoms: {', '.join(medical_conditions[condition]['symptoms'])}")
                st.write(f"Recommended actions: {', '.join(medical_conditions[condition]['treatment'])}")
                st.write("---")
            
            if st.button("Clear Symptoms"):
                st.session_state.current_symptoms = []
                st.rerun()
    
    with tabs[2]:
        st.subheader("Health History")
        patient_diagnoses = [d for d in st.session_state.diagnoses_db if d["patient_id"] == patient_id]
        
        if not patient_diagnoses:
            st.info("No diagnosis records found. Use the Symptom Checker to get your first diagnosis.")
        else:
            for i, diagnosis in enumerate(patient_diagnoses):
                with st.expander(f"Diagnosis #{i+1} - {diagnosis.get('timestamp', 'Unknown date')}"):
                    st.write(f"**Top condition:** {diagnosis['possible_diagnoses'][0]['condition'] if diagnosis['possible_diagnoses'] else 'Unknown'}")
                    st.write(f"**Confidence:** {diagnosis['ai_confidence_score']:.2f}")
                    st.write(f"**Follow-up required:** {'Yes' if diagnosis['follow_up_required'] else 'No'}")
                    st.write(f"**Recommendations:** {', '.join(diagnosis['recommendations'])}")
    
    with tabs[3]:
        st.subheader("Ask a Health Question")
        health_question = st.text_area("Enter your health question")
        
        if st.button("Submit Question"):
            if health_question:
                st.info("This would normally call the API endpoint for health questions")
                prompt = f"""
                You are HealthAI, an intelligent healthcare assistant. Please provide accurate, helpful medical information.
                Remember that you should not replace professional medical advice.

                Patient context: {patient['age']} year old {patient['gender']} with history of {', '.join(patient['medical_history'])}

                Question: {health_question}
                """
                response = llm(prompt)
                
                st.write("**Answer:**")
                st.write(response)
                st.write("---")
                st.write("*This information is not a substitute for professional medical advice. Always consult with a qualified healthcare provider.*")

def display_admin_dashboard():
    st.title("Admin Dashboard")
    st.write(f"Welcome, Admin {st.session_state.user_id}!")
    
    tabs = st.tabs(["Patient Management", "System Analytics", "Settings"])
    
    with tabs[0]:
        st.subheader("Patient Management")
        st.write("All registered patients:")
        
        for patient_id, patient in st.session_state.patients_db.items():
            with st.expander(f"Patient: {patient['name']} (ID: {patient_id})"):
                st.write(f"**Age:** {patient['age']}")
                st.write(f"**Gender:** {patient['gender']}")
                st.write(f"**Medical History:** {', '.join(patient['medical_history'])}")
                
                if st.button(f"View Complete Records for {patient_id}", key=f"view_{patient_id}"):
                    st.session_state.selected_patient = patient_id
                    st.rerun()
    
    with tabs[1]:
        st.subheader("System Analytics")
        st.info("This feature is under development")
        
        # Mock analytics
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total Patients", len(st.session_state.patients_db))
        with col2:
            st.metric("Total Diagnoses", len(st.session_state.diagnoses_db))
        with col3:
            st.metric("Avg. Confidence Score", "0.78")
            
    with tabs[2]:
        st.subheader("System Settings")
        st.info("This feature is under development")
        
        st.checkbox("Enable advanced diagnostics", value=True)
        st.checkbox("Send email notifications", value=False)
        st.slider("Confidence threshold for urgent care", 0.0, 1.0, 0.7)
        
        if st.button("Save Settings"):
            st.success("Settings saved successfully")

    if st.sidebar.button("Logout"):
        st.session_state.logged_in = False
        st.session_state.user_type = None
        st.session_state.user_id = None
        st.rerun()

# Main function to run Streamlit app
def main():
    create_streamlit_app()

if __name__ == "__main__":
    main()